// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Helpers$ReactTemplate = require("../Helpers.bs.js");
var Definition$ReactTemplate = require("../Definition.bs.js");

function getNibPosition(connectionSide, isSink, nodeLayouts, nodes, definition, graphWidth, definitions) {
  var match = connectionSide[/* node */0];
  if (match) {
    var nodeID = match[0];
    var nodePosition = Belt_MapString.getExn(nodeLayouts, nodeID)[/* position */0];
    var nibIndex = Definition$ReactTemplate.getNodeNibIndex(Belt_MapString.getExn(nodes, nodeID), definitions, connectionSide[/* nib */1], isSink);
    return /* record */Block.record([
              "columns",
              "rows"
            ], [
              nodePosition[/* columns */0],
              nodePosition[/* rows */1] + nibIndex | 0
            ]);
  } else {
    var nibIndex$1 = Helpers$ReactTemplate.findByIndexExn(isSink ? definition[/* display */2][/* outputOrdering */1] : definition[/* display */2][/* inputOrdering */0], (function (nibID) {
            return Caml_obj.caml_equal(/* NibConnection */Block.variant("NibConnection", 0, [nibID]), connectionSide[/* nib */1]);
          }));
    return /* record */Block.record([
              "columns",
              "rows"
            ], [
              isSink ? -1 : graphWidth - 2 | 0,
              nibIndex$1 + 1 | 0
            ]);
  }
}

function getParentScopes(nodeID, nodes) {
  var match = Belt_MapString.getExn(nodes, nodeID)[/* scope */0];
  if (match) {
    var nodeID$1 = match[0];
    return /* :: */Block.simpleVariant("::", [
              nodeID$1,
              getParentScopes(nodeID$1, nodes)
            ]);
  } else {
    return /* [] */0;
  }
}

function collisionDetect(nodeLayout, nodePosition) {
  if (nodePosition[/* columns */0] >= nodeLayout[/* position */0][/* columns */0] && nodePosition[/* columns */0] < (nodeLayout[/* position */0][/* columns */0] + nodeLayout[/* size */1][/* columns */0] | 0) && nodePosition[/* rows */1] >= nodeLayout[/* position */0][/* rows */1]) {
    return nodePosition[/* rows */1] <= (nodeLayout[/* position */0][/* rows */1] + nodeLayout[/* size */1][/* rows */1] | 0);
  } else {
    return false;
  }
}

function calculate(nodeLayouts, connections, nodes, definition, definitions, graphWidth) {
  return Belt_Map.mapWithKey(connections, (function (sink, source) {
                var startPosition = getNibPosition(sink, true, nodeLayouts, nodes, definition, graphWidth, definitions);
                var endPosition = getNibPosition(source, false, nodeLayouts, nodes, definition, graphWidth, definitions);
                var length = (endPosition[/* columns */0] - startPosition[/* columns */0] | 0) - 1 | 0;
                var match = sink[/* node */0];
                var parentScopes = Belt_SetString.fromArray(Belt_List.toArray(match ? getParentScopes(match[0], nodes) : /* [] */0));
                return Belt_List.reverse(Belt_List.reduce(Belt_List.makeBy(length, (function (index) {
                                        return index;
                                      })), /* tuple */[
                                  /* [] */0,
                                  endPosition[/* rows */1]
                                ], (function (param, index) {
                                    var rows = param[1];
                                    var columns = (endPosition[/* columns */0] - index | 0) - 1 | 0;
                                    var position = /* record */Block.record([
                                        "columns",
                                        "rows"
                                      ], [
                                        columns,
                                        rows
                                      ]);
                                    var collisions = Belt_MapString.keep(nodeLayouts, (function (nodeID, layout) {
                                            if (Belt_SetString.has(parentScopes, nodeID)) {
                                              return false;
                                            } else {
                                              return collisionDetect(layout, position);
                                            }
                                          }));
                                    var rows$1;
                                    if (Belt_MapString.isEmpty(collisions)) {
                                      rows$1 = rows;
                                    } else {
                                      var collisions$1 = Belt_List.fromArray(Belt_MapString.valuesToArray(collisions));
                                      var outermostCollision = Belt_List.reduce(List.tl(collisions$1), List.hd(collisions$1), (function (acc, layout) {
                                              var match = layout[/* depth */2] > acc[/* depth */2];
                                              if (match) {
                                                return layout;
                                              } else {
                                                return acc;
                                              }
                                            }));
                                      var bottom = outermostCollision[/* position */0][/* rows */1] + outermostCollision[/* size */1][/* rows */1] | 0;
                                      rows$1 = Pervasives.abs(outermostCollision[/* position */0][/* rows */1] - rows | 0) < Pervasives.abs(bottom - rows | 0) ? outermostCollision[/* position */0][/* rows */1] - 1 | 0 : bottom;
                                    }
                                    return /* tuple */[
                                            /* :: */Block.simpleVariant("::", [
                                                rows$1,
                                                param[0]
                                              ]),
                                            rows$1
                                          ];
                                  }))[0]);
              }));
}

exports.getNibPosition = getNibPosition;
exports.getParentScopes = getParentScopes;
exports.collisionDetect = collisionDetect;
exports.calculate = calculate;
/* Helpers-ReactTemplate Not a pure module */
