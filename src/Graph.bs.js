// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Nib$ReactTemplate = require("./Nib.bs.js");
var Node$ReactTemplate = require("./Node.bs.js");
var Helpers$ReactTemplate = require("./Helpers.bs.js");
var Evaluate$ReactTemplate = require("./Evaluate.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Connection$ReactTemplate = require("./Connection.bs.js");
var Definition$ReactTemplate = require("./Definition.bs.js");
var DetectCycles$ReactTemplate = require("./DetectCycles.bs.js");
var GraphActions$ReactTemplate = require("./GraphActions.bs.js");
var ColumnizeNodes$ReactTemplate = require("./ColumnizeNodes.bs.js");

var cmp = Caml_obj.caml_compare;

var PointerComparator = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

var $$document = document;

function preventDefault($$event) {
  $$event.preventDefault();
  return /* () */0;
}

var component = ReasonReact.reducerComponent("Graph");

function make(definitions, implementation, display, documentation, size, emit, _children) {
  return /* record */[
          /* debugName */component[/* debugName */0],
          /* reactClassInternal */component[/* reactClassInternal */1],
          /* handedOffState */component[/* handedOffState */2],
          /* willReceiveProps */component[/* willReceiveProps */3],
          /* didMount */(function (param) {
              $$document.addEventListener("touchmove", preventDefault, {
                    passive: false,
                    capture: true,
                    once: false
                  });
              return /* () */0;
            }),
          /* didUpdate */component[/* didUpdate */5],
          /* willUnmount */(function (param) {
              $$document.removeEventListener("touchmove", preventDefault);
              return /* () */0;
            }),
          /* willUpdate */component[/* willUpdate */7],
          /* shouldUpdate */component[/* shouldUpdate */8],
          /* render */(function (self) {
              var columns = ColumnizeNodes$ReactTemplate.topoSort(implementation[/* nodes */1], implementation[/* connections */0]);
              var columnWidth = size[/* x */0] / (List.length(columns) + 1 | 0);
              var nodeHeight = function (node) {
                return 20.0 * (1 + Definition$ReactTemplate.countNodeNibs(node, definitions) | 0);
              };
              var nodePositions = Belt_MapString.mergeMany(Belt_MapString.empty, $$Array.of_list(List.flatten(List.mapi((function (column, nodes) {
                                  var rowHeight = size[/* y */1] / (Belt_MapString.size(nodes) + 1 | 0);
                                  return Belt_List.mapWithIndex(Belt_MapString.toList(nodes), (function (row, param) {
                                                return /* tuple */[
                                                        param[0],
                                                        /* record */[
                                                          /* x */columnWidth * (column + 1 | 0) - 80.0 / 2.0,
                                                          /* y */rowHeight * (row + 1 | 0) - nodeHeight(param[1]) / 2.0
                                                        ]
                                                      ];
                                              }));
                                }), columns))));
              var nibPositions = function (nibIds, isInput) {
                var rowHeight = size[/* y */1] / (List.length(nibIds) + 1 | 0);
                return Belt_MapString.fromArray($$Array.of_list(List.mapi((function (index, nibID) {
                                      return /* tuple */[
                                              nibID,
                                              /* record */[
                                                /* x */isInput ? size[/* x */0] - 10.0 : 10.0,
                                                /* y */(index + 1 | 0) * rowHeight
                                              ]
                                            ];
                                    }), nibIds)));
              };
              var inputPositions = nibPositions(display[/* inputOrdering */0], true);
              var outputPositions = nibPositions(display[/* outputOrdering */1], false);
              var getNibPosition = function (connectionSide, isSink) {
                var match = connectionSide[/* node */0];
                if (match) {
                  var nodeID = match[0];
                  var nodePosition = Belt_MapString.getExn(nodePositions, nodeID);
                  var node = Belt_MapString.getExn(implementation[/* nodes */1], nodeID);
                  return /* record */[
                          /* x */nodePosition[/* x */0] + (
                            isSink ? 80.0 : 0.0
                          ),
                          /* y */(Definition$ReactTemplate.getNodeNibIndex(node, definitions, connectionSide[/* nib */1], isSink) + 1 | 0) * 20.0 + 20.0 / 2.0 + nodePosition[/* y */1]
                        ];
                } else {
                  var match$1 = connectionSide[/* nib */1];
                  if (typeof match$1 === "number") {
                    throw Caml_builtin_exceptions.not_found;
                  } else if (match$1.tag) {
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    return Belt_MapString.getExn(isSink ? outputPositions : inputPositions, match$1[0]);
                  }
                }
              };
              var getNibNudge = function (source) {
                var match = source[/* node */0];
                if (match) {
                  var node = Belt_MapString.getExn(implementation[/* nodes */1], match[0]);
                  return Definition$ReactTemplate.getOutputIndex(node, definitions, source[/* nib */1]);
                } else {
                  var match$1 = source[/* nib */1];
                  if (typeof match$1 === "number") {
                    throw Caml_builtin_exceptions.not_found;
                  } else if (match$1.tag) {
                    throw Caml_builtin_exceptions.not_found;
                  } else {
                    return Helpers$ReactTemplate.findIndexExn(display[/* inputOrdering */0], match$1[0]);
                  }
                }
              };
              var changeName = function ($$event) {
                return Curry._1(emit, /* ChangeName */Block.__(1, [Helpers$ReactTemplate.getEventValue($$event)]));
              };
              var match = self[/* state */1][/* error */1];
              return React.createElement("div", {
                          className: "graph",
                          onMouseMove: (function ($$event) {
                              $$event.preventDefault();
                              return Curry._1(self[/* send */3], /* ContinueDrawing */Block.__(1, [/* record */[
                                              /* pointerID : Mouse */0,
                                              /* point */Helpers$ReactTemplate.pointFromMouse($$event)
                                            ]]));
                            }),
                          onMouseUp: (function (param) {
                              return Curry._1(self[/* send */3], /* StopDrawing */Block.__(3, [/* record */[/* pointerID : Mouse */0]]));
                            }),
                          onTouchEnd: (function ($$event) {
                              return Helpers$ReactTemplate.iterateTouches($$event, (function (touch) {
                                            return Curry._1(self[/* send */3], /* StopDrawing */Block.__(3, [/* record */[/* pointerID : Touch */[touch.identifier]]]));
                                          }));
                            }),
                          onTouchMove: (function ($$event) {
                              return Helpers$ReactTemplate.iterateTouches($$event, (function (touch) {
                                            return Curry._1(self[/* send */3], /* ContinueDrawing */Block.__(1, [/* record */[
                                                            /* pointerID : Touch */[touch.identifier],
                                                            /* point : record */[
                                                              /* x */touch.clientX,
                                                              /* y */touch.clientY
                                                            ]
                                                          ]]));
                                          }));
                            })
                        }, React.createElement("input", {
                              className: "graph-name",
                              type: "text",
                              value: Definition$ReactTemplate.getTranslated(documentation[/* name */0], "en"),
                              onChange: changeName
                            }), match !== undefined ? React.createElement("div", {
                                className: "error-message"
                              }, match) : null, Helpers$ReactTemplate.renderMap((function (param) {
                                var source = param[1];
                                var sink = param[0];
                                return ReasonReact.element(Definition$ReactTemplate.connectionSideToString(sink), undefined, Connection$ReactTemplate.make(getNibPosition(source, false), getNibPosition(sink, true), getNibNudge(source), undefined, /* array */[]));
                              }), implementation[/* connections */0]), Helpers$ReactTemplate.renderMap((function (param) {
                                var match = param[1];
                                var point = match[/* point */2];
                                var startIsSource = match[/* startIsSource */1];
                                var connectionSide = match[/* connectionSide */0];
                                return ReasonReact.element(GraphActions$ReactTemplate.pointerIDToString(param[0]), undefined, Connection$ReactTemplate.make(startIsSource ? getNibPosition(connectionSide, false) : point, startIsSource ? point : getNibPosition(connectionSide, true), startIsSource ? getNibNudge(connectionSide) : 0, undefined, /* array */[]));
                              }), self[/* state */1][/* pointers */0]), Belt_List.toArray(Belt_List.map(display[/* inputOrdering */0], (function (nibID) {
                                    var name = Definition$ReactTemplate.getTranslated(Belt_MapString.getExn(documentation[/* inputs */2], nibID), "en");
                                    return React.createElement("div", {
                                                key: nibID,
                                                className: "graph-input input",
                                                style: {
                                                  right: Helpers$ReactTemplate.pixels(10.0),
                                                  top: Helpers$ReactTemplate.pixels(Belt_MapString.getExn(inputPositions, nibID)[/* y */1])
                                                }
                                              }, name, ReasonReact.element(undefined, undefined, Nib$ReactTemplate.make(true, /* record */[
                                                        /* node : GraphConnection */0,
                                                        /* nib : NibConnection */Block.__(0, [nibID])
                                                      ], self[/* send */3], /* array */[])));
                                  }))), Belt_List.toArray(Belt_List.map(display[/* outputOrdering */1], (function (nibID) {
                                    var name = Definition$ReactTemplate.getTranslated(Belt_MapString.getExn(documentation[/* outputs */3], nibID), "en");
                                    return React.createElement("div", {
                                                key: nibID,
                                                className: "graph-output output",
                                                style: Helpers$ReactTemplate.positionStyle(Belt_MapString.getExn(outputPositions, nibID))
                                              }, ReasonReact.element(undefined, undefined, Nib$ReactTemplate.make(false, /* record */[
                                                        /* node : GraphConnection */0,
                                                        /* nib : NibConnection */Block.__(0, [nibID])
                                                      ], self[/* send */3], /* array */[])), React.createElement("div", undefined, name), React.createElement("a", {
                                                    onClick: (function (_event) {
                                                        var outputID = nibID;
                                                        console.log(Evaluate$ReactTemplate.evaluateGraphOutput(definitions, implementation, outputID));
                                                        return /* () */0;
                                                      })
                                                  }, "Evaluate"));
                                  }))), Helpers$ReactTemplate.renderStringMap((function (param) {
                                var nodeID = param[0];
                                return ReasonReact.element(nodeID, undefined, Node$ReactTemplate.make(nodeID, param[1], definitions, Belt_MapString.getExn(nodePositions, nodeID), self[/* send */3], /* array */[]));
                              }), implementation[/* nodes */1]));
            }),
          /* initialState */(function (param) {
              return /* record */[
                      /* pointers */Belt_Map.make(PointerComparator),
                      /* error */undefined
                    ];
            }),
          /* retainedProps */component[/* retainedProps */11],
          /* reducer */(function (action, state) {
              switch (action.tag | 0) {
                case 0 : 
                    var match = action[0];
                    return /* Update */Block.__(0, [/* record */[
                                /* pointers */Belt_Map.set(state[/* pointers */0], match[/* pointerID */0], match[/* drawingConnection */1]),
                                /* error */state[/* error */1]
                              ]]);
                case 1 : 
                    var match$1 = action[0];
                    var pointerID = match$1[/* pointerID */0];
                    var match$2 = Belt_Map.get(state[/* pointers */0], pointerID);
                    if (match$2 !== undefined) {
                      var drawingConnection = match$2;
                      return /* Update */Block.__(0, [/* record */[
                                  /* pointers */Belt_Map.set(state[/* pointers */0], pointerID, /* record */[
                                        /* connectionSide */drawingConnection[/* connectionSide */0],
                                        /* startIsSource */drawingConnection[/* startIsSource */1],
                                        /* point */match$1[/* point */1]
                                      ]),
                                  /* error */state[/* error */1]
                                ]]);
                    } else {
                      return /* NoUpdate */0;
                    }
                case 2 : 
                    var match$3 = action[0];
                    var end_nib = match$3[/* connectionSide */1];
                    var pointerID$1 = match$3[/* pointerID */0];
                    var match$4 = Belt_Map.get(state[/* pointers */0], pointerID$1);
                    if (match$4 !== undefined) {
                      var match$5 = match$4;
                      var startIsSource = match$5[/* startIsSource */1];
                      var start_nib = match$5[/* connectionSide */0];
                      var match$6 = startIsSource !== match$3[/* isSource */2];
                      if (match$6) {
                        var match$7 = DetectCycles$ReactTemplate.detectCycles(Belt_Map.set(implementation[/* connections */0], startIsSource ? end_nib : start_nib, startIsSource ? start_nib : end_nib), implementation[/* nodes */1]);
                        if (match$7) {
                          return /* Update */Block.__(0, [/* record */[
                                      /* pointers */state[/* pointers */0],
                                      /* error */"Can't create cycles"
                                    ]]);
                        } else {
                          return /* UpdateWithSideEffects */Block.__(2, [
                                    /* record */[
                                      /* pointers */Belt_Map.remove(state[/* pointers */0], pointerID$1),
                                      /* error */undefined
                                    ],
                                    (function (param) {
                                        return Curry._1(emit, /* CreateConnection */Block.__(0, [/* record */[
                                                        /* source */startIsSource ? start_nib : end_nib,
                                                        /* sink */startIsSource ? end_nib : start_nib
                                                      ]]));
                                      })
                                  ]);
                        }
                      } else {
                        return /* Update */Block.__(0, [/* record */[
                                    /* pointers */state[/* pointers */0],
                                    /* error */startIsSource ? "Can't connect a source to a source" : "Can't connect a sink to a sink"
                                  ]]);
                      }
                    } else {
                      return /* NoUpdate */0;
                    }
                case 3 : 
                    var pointerID$2 = action[0][/* pointerID */0];
                    var match$8 = Belt_Map.has(state[/* pointers */0], pointerID$2);
                    if (match$8) {
                      return /* Update */Block.__(0, [/* record */[
                                  /* pointers */Belt_Map.remove(state[/* pointers */0], pointerID$2),
                                  /* error */state[/* error */1]
                                ]]);
                    } else {
                      return /* NoUpdate */0;
                    }
                
              }
            }),
          /* jsElementWrapped */component[/* jsElementWrapped */13]
        ];
}

exports.PointerComparator = PointerComparator;
exports.$$document = $$document;
exports.preventDefault = preventDefault;
exports.component = component;
exports.make = make;
/* PointerComparator Not a pure module */
