// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Debug = require("bs-platform/lib/js/belt_Debug.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Helpers$ReactTemplate = require("./Helpers.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

Belt_Debug.setupChromeDebugger(/* () */0);

function encodeConnectionNode(connectionNode) {
  return Json_encode.object_(connectionNode ? /* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "node"
                  ],
                  /* :: */Block.simpleVariant("::", [
                      /* tuple */[
                        "nodeID",
                        connectionNode[0]
                      ],
                      /* [] */0
                    ])
                ]) : /* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "graph"
                  ],
                  /* [] */0
                ]));
}

function connectionNodeToString(connectionNode) {
  if (connectionNode) {
    return "node-" + connectionNode[0];
  } else {
    return "graph";
  }
}

function encodeConnectionNib(connectionNib) {
  var tmp;
  tmp = typeof connectionNib === "number" ? /* :: */Block.simpleVariant("::", [
        /* tuple */[
          "type",
          "value"
        ],
        /* [] */0
      ]) : (
      connectionNib.tag ? /* :: */Block.simpleVariant("::", [
            /* tuple */[
              "type",
              "positional"
            ],
            /* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "index",
                  connectionNib[0]
                ],
                /* [] */0
              ])
          ]) : /* :: */Block.simpleVariant("::", [
            /* tuple */[
              "type",
              "nib"
            ],
            /* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "nibID",
                  connectionNib[0]
                ],
                /* [] */0
              ])
          ])
    );
  return Json_encode.object_(tmp);
}

function connectionNibToString(connectionNib) {
  if (typeof connectionNib === "number") {
    return "value";
  } else if (connectionNib.tag) {
    return "index-" + String(connectionNib[0]);
  } else {
    return "nib-" + connectionNib[0];
  }
}

function encodeConnectionSide(connectionSide) {
  return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "node",
                  encodeConnectionNode(connectionSide[/* node */0])
                ],
                /* :: */Block.simpleVariant("::", [
                    /* tuple */[
                      "nib",
                      encodeConnectionNib(connectionSide[/* nib */1])
                    ],
                    /* [] */0
                  ])
              ]));
}

function connectionSideToString(connectionSide) {
  return connectionNodeToString(connectionSide[/* node */0]) + ("-" + connectionNibToString(connectionSide[/* nib */1]));
}

var cmp = Caml_obj.caml_compare;

var ConnectionComparator = Belt_Id.MakeComparable(/* module */Block.localModule(["cmp"], [cmp]));

function nibKey(connectionNib) {
  if (typeof connectionNib === "number") {
    return "value";
  } else if (connectionNib.tag) {
    return String(connectionNib[0]);
  } else {
    return connectionNib[0];
  }
}

function nodeKey(connectionNode) {
  if (connectionNode) {
    return connectionNode[0];
  } else {
    return "graph";
  }
}

function explicitConnectionSideKey(explicitConnectionSide) {
  var match = explicitConnectionSide[/* isSource */1];
  return Curry._3(Printf.sprintf(/* Format */Block.simpleVariant("Format", [
                    /* String_literal */Block.variant("String_literal", 11, [
                        "nib-",
                        /* String */Block.variant("String", 2, [
                            /* No_padding */0,
                            /* Char_literal */Block.variant("Char_literal", 12, [
                                /* "-" */45,
                                /* String */Block.variant("String", 2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.variant("Char_literal", 12, [
                                        /* "-" */45,
                                        /* String */Block.variant("String", 2, [
                                            /* No_padding */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "nib-%s-%s-%s"
                  ])), nodeKey(explicitConnectionSide[/* connectionSide */0][/* node */0]), nibKey(explicitConnectionSide[/* connectionSide */0][/* nib */1]), match ? "source" : "sink");
}

function definedNodeKindToString(kind) {
  switch (kind) {
    case 0 : 
        return "function call";
    case 1 : 
        return "value";
    case 2 : 
        return "function pointer call";
    case 3 : 
        return "function definition";
    case 4 : 
        return "constructor";
    case 5 : 
        return "accessor";
    
  }
}

function definedNodeKindHasValueInput(kind) {
  if (kind !== 2) {
    return kind >= 5;
  } else {
    return true;
  }
}

function definedNodeKindHasValueOutput(kind) {
  switch (kind) {
    case 1 : 
    case 3 : 
    case 4 : 
        return true;
    case 0 : 
    case 2 : 
    case 5 : 
        return false;
    
  }
}

function encodeDefinedNode(definedNode) {
  return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "type",
                  "defined"
                ],
                /* :: */Block.simpleVariant("::", [
                    /* tuple */[
                      "definitionID",
                      definedNode[/* definitionID */1]
                    ],
                    /* :: */Block.simpleVariant("::", [
                        /* tuple */[
                          "kind",
                          definedNodeKindToString(definedNode[/* kind */0])
                        ],
                        /* [] */0
                      ])
                  ])
              ]));
}

function encodeNodeKind(nodeKind) {
  if (typeof nodeKind === "number") {
    return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "reference"
                  ],
                  /* [] */0
                ]));
  } else if (nodeKind.tag) {
    return encodeDefinedNode(nodeKind[0]);
  } else {
    return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "list"
                  ],
                  /* :: */Block.simpleVariant("::", [
                      /* tuple */[
                        "length",
                        nodeKind[0]
                      ],
                      /* [] */0
                    ])
                ]));
  }
}

function encodeNodeScope(nodeScope) {
  return Json_encode.object_(nodeScope ? /* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "node"
                  ],
                  /* :: */Block.simpleVariant("::", [
                      /* tuple */[
                        "nodeID",
                        nodeScope[0]
                      ],
                      /* [] */0
                    ])
                ]) : /* :: */Block.simpleVariant("::", [
                  /* tuple */[
                    "type",
                    "graph"
                  ],
                  /* [] */0
                ]));
}

var cmp$1 = Caml_obj.caml_compare;

var ScopeComparator = Belt_Id.MakeComparable(/* module */Block.localModule(["cmp"], [cmp$1]));

function encodeNode(node) {
  return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "scope",
                  encodeNodeScope(node[/* scope */0])
                ],
                /* :: */Block.simpleVariant("::", [
                    /* tuple */[
                      "kind",
                      encodeNodeKind(node[/* kind */1])
                    ],
                    /* [] */0
                  ])
              ]));
}

function isFunctionDefinitionNode(node) {
  var match = node[/* kind */1];
  if (typeof match === "number" || !match.tag) {
    return false;
  } else {
    return match[0][/* kind */0] === 3;
  }
}

function isValueNib(nib) {
  if (typeof nib === "number") {
    return true;
  } else {
    return false;
  }
}

function isKeywordNib(nib) {
  if (typeof nib === "number" || nib.tag) {
    return false;
  } else {
    return true;
  }
}

var primitiveValueTypes = /* array */[
  /* TextType */2,
  /* NumberType */1
];

function primitiveValueTypeToString(primitiveValueType) {
  switch (primitiveValueType) {
    case 0 : 
        return "integer";
    case 1 : 
        return "number";
    case 2 : 
        return "text";
    
  }
}

function stringToPrimitiveValueType(string) {
  switch (string) {
    case "integer" : 
        return /* IntegerType */0;
    case "number" : 
        return /* NumberType */1;
    case "text" : 
        return /* TextType */2;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

var cmp$2 = Caml_obj.caml_compare;

var ValueTypeComparator = Belt_Id.MakeComparable(/* module */Block.localModule(["cmp"], [cmp$2]));

var changeTypedFields = Belt_MapString.set;

function changeInterface($$interface, isInput, nibID, valueType) {
  if (isInput) {
    return /* record */Block.record([
              "inputTypes",
              "outputTypes"
            ], [
              Belt_MapString.set($$interface[/* inputTypes */0], nibID, valueType),
              $$interface[/* outputTypes */1]
            ]);
  } else {
    return /* record */Block.record([
              "inputTypes",
              "outputTypes"
            ], [
              $$interface[/* inputTypes */0],
              Belt_MapString.set($$interface[/* outputTypes */1], nibID, valueType)
            ]);
  }
}

function editInterfaceNibs($$interface, isInput, mutation) {
  if (isInput) {
    return /* record */Block.record([
              "inputTypes",
              "outputTypes"
            ], [
              Curry._1(mutation, $$interface[/* inputTypes */0]),
              $$interface[/* outputTypes */1]
            ]);
  } else {
    return /* record */Block.record([
              "inputTypes",
              "outputTypes"
            ], [
              $$interface[/* inputTypes */0],
              Curry._1(mutation, $$interface[/* outputTypes */1])
            ]);
  }
}

function removeInterfaceNib($$interface, nibID, isInput) {
  return editInterfaceNibs($$interface, isInput, (function (fields) {
                return Belt_MapString.keep(fields, (function (interfaceNibID, param) {
                              return interfaceNibID !== nibID;
                            }));
              }));
}

function encodeMap(map, encode) {
  return Json_encode.object_(Belt_List.map(Belt_MapString.toList(map), (function (param) {
                    return /* tuple */[
                            param[0],
                            Curry._1(encode, param[1])
                          ];
                  })));
}

function encodeGraphImplementation(graphImplementation) {
  return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                /* tuple */[
                  "nodes",
                  encodeMap(graphImplementation[/* nodes */2], encodeNode)
                ],
                /* :: */Block.simpleVariant("::", [
                    /* tuple */[
                      "connections",
                      Json_encode.list((function (param) {
                              return Json_encode.object_(/* :: */Block.simpleVariant("::", [
                                            /* tuple */[
                                              "sink",
                                              encodeConnectionSide(param[0])
                                            ],
                                            /* :: */Block.simpleVariant("::", [
                                                /* tuple */[
                                                  "source",
                                                  encodeConnectionSide(param[1])
                                                ],
                                                /* [] */0
                                              ])
                                          ]));
                            }), Belt_Map.toList(graphImplementation[/* connections */1]))
                    ],
                    /* [] */0
                  ])
              ]));
}

function primitiveValueToType(primitiveValue) {
  switch (primitiveValue.tag | 0) {
    case 0 : 
        return /* IntegerType */0;
    case 1 : 
        return /* NumberType */1;
    case 2 : 
        return /* TextType */2;
    
  }
}

function primitiveValueToString(primitiveValue) {
  switch (primitiveValue.tag | 0) {
    case 0 : 
        return String(primitiveValue[0]);
    case 1 : 
        return Helpers$ReactTemplate.floatToString(primitiveValue[0]);
    case 2 : 
        return primitiveValue[0];
    
  }
}

function displayPrimitiveValue(primitiveValue) {
  switch (primitiveValue.tag | 0) {
    case 0 : 
    case 1 : 
        return primitiveValueToString(primitiveValue);
    case 2 : 
        return "\"" + (primitiveValue[0] + "\"");
    
  }
}

function primitiveValueToTypeString(x) {
  return primitiveValueTypeToString(primitiveValueToType(x));
}

function displayValue(value) {
  if (value.tag) {
    return "TODO: defined value";
  } else {
    return displayPrimitiveValue(value[0]);
  }
}

function implementationName(implementation) {
  switch (implementation.tag | 0) {
    case 0 : 
        return "constant";
    case 1 : 
        return "interface";
    case 2 : 
        return "external";
    case 3 : 
        return "function";
    case 4 : 
        return "record type";
    case 5 : 
        return "labeled type";
    case 6 : 
        return "union type";
    
  }
}

function getTranslated(translatable, language) {
  return Belt_MapString.getExn(translatable[/* translations */1], language)[/* text */0];
}

function setTranslated(translatable, language, text) {
  return /* record */Block.record([
            "sourceLanguage",
            "translations"
          ], [
            translatable[/* sourceLanguage */0],
            Belt_MapString.update(translatable[/* translations */1], language, (function (maybeVettable) {
                    if (maybeVettable !== undefined) {
                      var vettable = maybeVettable;
                      return /* record */Block.record([
                                "text",
                                "vetted",
                                "authorID"
                              ], [
                                text,
                                vettable[/* vetted */1],
                                vettable[/* authorID */2]
                              ]);
                    } else {
                      return /* record */Block.record([
                                "text",
                                "vetted",
                                "authorID"
                              ], [
                                text,
                                false,
                                undefined
                              ]);
                    }
                  }))
          ]);
}

function makeTranslatable(text, language) {
  return /* record */Block.record([
            "sourceLanguage",
            "translations"
          ], [
            language,
            Belt_MapString.fromArray(/* array */[/* tuple */[
                    language,
                    /* record */Block.record([
                        "text",
                        "vetted",
                        "authorID"
                      ], [
                        text,
                        true,
                        undefined
                      ])
                  ]])
          ]);
}

var emptyTranslatable = makeTranslatable("", "en");

function getDisplayName(definition, language) {
  var text = getTranslated(definition[/* documentation */1][/* name */0], language);
  if (text !== "") {
    return text;
  } else {
    var match = definition[/* implementation */0];
    if (match.tag) {
      return "(nameless " + (implementationName(definition[/* implementation */0]) + ")");
    } else {
      return displayPrimitiveValue(match[0]);
    }
  }
}

function displayKeywordNibs(definition, language, isInputs) {
  return Belt_List.map(isInputs ? definition[/* display */2][/* inputOrdering */0] : definition[/* display */2][/* outputOrdering */1], (function (nibID) {
                var documentation = definition[/* documentation */1];
                var nibs = isInputs ? documentation[/* inputs */2] : documentation[/* outputs */3];
                var translatable = Belt_MapString.getExn(nibs, nibID);
                var vettable = Belt_MapString.getExn(translatable[/* translations */1], language);
                return /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          vettable[/* text */0],
                          Block.variant("NibConnection", 0, [nibID])
                        ]);
              }));
}

function displayKeywordInputs(definition, language) {
  return displayKeywordNibs(definition, language, true);
}

function displayKeywordOutputs(definition, language) {
  return displayKeywordNibs(definition, language, false);
}

function makeDisplayNibs($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, _unit) {
  var inputs = $staropt$star !== undefined ? $staropt$star : /* [] */0;
  var outputs = $staropt$star$1 !== undefined ? $staropt$star$1 : /* [] */0;
  var internalInputs = $staropt$star$2 !== undefined ? $staropt$star$2 : /* [] */0;
  var internalOutputs = $staropt$star$3 !== undefined ? $staropt$star$3 : /* [] */0;
  return /* record */Block.record([
            "inputs",
            "outputs",
            "internalInputs",
            "internalOutputs"
          ], [
            inputs,
            outputs,
            internalInputs,
            internalOutputs
          ]);
}

function displayDefinedNode(definition, kind, language) {
  switch (kind) {
    case 0 : 
        return makeDisplayNibs(displayKeywordNibs(definition, language, true), displayKeywordNibs(definition, language, false), undefined, undefined, /* () */0);
    case 1 : 
        return makeDisplayNibs(undefined, /* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          "",
                          0
                        ]),
                      /* [] */0
                    ]), undefined, undefined, /* () */0);
    case 2 : 
        return makeDisplayNibs(/* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          "implementation",
                          0
                        ]),
                      displayKeywordNibs(definition, language, true)
                    ]), displayKeywordNibs(definition, language, false), undefined, undefined, /* () */0);
    case 3 : 
        return makeDisplayNibs(undefined, /* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          "",
                          0
                        ]),
                      /* [] */0
                    ]), displayKeywordNibs(definition, language, true), displayKeywordNibs(definition, language, false), /* () */0);
    case 4 : 
        return makeDisplayNibs(displayKeywordNibs(definition, language, true), /* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          "",
                          0
                        ]),
                      /* [] */0
                    ]), undefined, undefined, /* () */0);
    case 5 : 
        return makeDisplayNibs(/* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "name",
                          "nib"
                        ], [
                          "",
                          0
                        ]),
                      /* [] */0
                    ]), displayKeywordNibs(definition, language, true), undefined, undefined, /* () */0);
    
  }
}

function displayNode(node, definitions, language) {
  var match = node[/* kind */1];
  if (typeof match === "number") {
    return makeDisplayNibs(undefined, /* :: */Block.simpleVariant("::", [
                  /* record */Block.record([
                      "name",
                      "nib"
                    ], [
                      "Reference",
                      0
                    ]),
                  /* [] */0
                ]), undefined, undefined, /* () */0);
  } else if (match.tag) {
    var match$1 = match[0];
    var definition = Belt_MapString.getExn(definitions, match$1[/* definitionID */1]);
    return displayDefinedNode(definition, match$1[/* kind */0], language);
  } else {
    return makeDisplayNibs(Belt_List.makeBy(match[0], (function (index) {
                      return /* record */Block.record([
                                "name",
                                "nib"
                              ], [
                                String(index),
                                Block.variant("PositionalConnection", 1, [index])
                              ]);
                    })), /* :: */Block.simpleVariant("::", [
                  /* record */Block.record([
                      "name",
                      "nib"
                    ], [
                      "",
                      0
                    ]),
                  /* [] */0
                ]), undefined, undefined, /* () */0);
  }
}

function displayNibsToExplicitConnectionSides(displayNibs, node, isSource) {
  return Belt_List.map(displayNibs, (function (displayNib) {
                return /* record */Block.record([
                          "name",
                          "explicitConnectionSide"
                        ], [
                          displayNib[/* name */0],
                          Block.record([
                              "connectionSide",
                              "isSource"
                            ], [
                              Block.record([
                                  "node",
                                  "nib"
                                ], [
                                  node,
                                  displayNib[/* nib */1]
                                ]),
                              isSource
                            ])
                        ]);
              }));
}

function collectGraphNodeNibs(nodes, definitions) {
  return Belt_List.reduce(Belt_MapString.toList(nodes), /* [] */0, (function (acc, param) {
                var match = displayNode(param[1], definitions, "en");
                var connectionNode = /* NodeConnection */Block.simpleVariant("NodeConnection", [param[0]]);
                return Belt_List.concatMany(/* array */[
                            acc,
                            displayNibsToExplicitConnectionSides(match[/* inputs */0], connectionNode, false),
                            displayNibsToExplicitConnectionSides(match[/* outputs */1], connectionNode, true),
                            displayNibsToExplicitConnectionSides(match[/* internalInputs */2], connectionNode, true),
                            displayNibsToExplicitConnectionSides(match[/* internalOutputs */3], connectionNode, false)
                          ]);
              }));
}

function collectAllGraphNibs(definition, definitions) {
  var match = definition[/* implementation */0];
  if (match.tag === 3) {
    return Belt_List.concatMany(/* array */[
                displayNibsToExplicitConnectionSides(displayKeywordNibs(definition, "en", false), /* GraphConnection */0, false),
                displayNibsToExplicitConnectionSides(displayKeywordNibs(definition, "en", true), /* GraphConnection */0, true),
                collectGraphNodeNibs(match[0][/* nodes */2], definitions)
              ]);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function functionDefinitionNibIndex(definition, connectionNib, isSink) {
  if (typeof connectionNib === "number") {
    return 0;
  } else if (connectionNib.tag) {
    throw Caml_builtin_exceptions.not_found;
  } else {
    var nibs = displayKeywordNibs(definition, "en", !isSink);
    return Helpers$ReactTemplate.findByIndexExn(nibs, (function (param) {
                  return Caml_obj.caml_equal(param[/* nib */1], connectionNib);
                }));
  }
}

function getNodeNibIndex(node, definitions, connectionNib, isSink) {
  var match = node[/* kind */1];
  var exit = 0;
  if (typeof match === "number" || !match.tag) {
    exit = 1;
  } else {
    var match$1 = match[0];
    if (match$1[/* kind */0] !== 3) {
      exit = 1;
    } else {
      return functionDefinitionNibIndex(Belt_MapString.getExn(definitions, match$1[/* definitionID */1]), connectionNib, isSink) + 1 | 0;
    }
  }
  if (exit === 1) {
    var match$2 = displayNode(node, definitions, "en");
    var inputs = match$2[/* inputs */0];
    var nibs = isSink ? inputs : match$2[/* outputs */1];
    var nibIndex = Helpers$ReactTemplate.findByIndexExn(nibs, (function (param) {
            return Caml_obj.caml_equal(param[/* nib */1], connectionNib);
          }));
    return (
            isSink ? nibIndex : nibIndex + Belt_List.length(inputs) | 0
          ) + 1 | 0;
  }
  
}

function getOutputIndex(node, definitions, connectionNib) {
  var match = node[/* kind */1];
  var exit = 0;
  if (typeof match === "number" || !match.tag) {
    exit = 1;
  } else {
    var match$1 = match[0];
    if (match$1[/* kind */0] !== 3) {
      exit = 1;
    } else {
      return functionDefinitionNibIndex(Belt_MapString.getExn(definitions, match$1[/* definitionID */1]), connectionNib, false);
    }
  }
  if (exit === 1) {
    var match$2 = displayNode(node, definitions, "en");
    return Helpers$ReactTemplate.findByIndexExn(match$2[/* outputs */1], (function (param) {
                  return Caml_obj.caml_equal(param[/* nib */1], connectionNib);
                }));
  }
  
}

function countNodeNibs(node, definitions) {
  var match = node[/* kind */1];
  if (typeof match === "number") {
    return 1;
  } else if (match.tag) {
    var match$1 = match[0];
    var nodeDefinition = Belt_MapString.getExn(definitions, match$1[/* definitionID */1]);
    var nodeDisplay = displayDefinedNode(nodeDefinition, match$1[/* kind */0], "en");
    return Belt_List.length(nodeDisplay[/* inputs */0]) + Belt_List.length(nodeDisplay[/* outputs */1]) | 0;
  } else {
    return match[0];
  }
}

function displayDefinedType(definition, language) {
  var match = definition[/* implementation */0];
  var tmp;
  switch (match.tag | 0) {
    case 1 : 
        tmp = "Function";
        break;
    case 4 : 
        tmp = "Record";
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return getTranslated(definition[/* documentation */1][/* name */0], language) + (" " + tmp);
}

function displayPrimitiveValueType(primitiveValueType) {
  switch (primitiveValueType) {
    case 0 : 
        return "Integer";
    case 1 : 
        return "Number";
    case 2 : 
        return "Text";
    
  }
}

function displayValueType(valueType, definitions, language) {
  if (typeof valueType === "number") {
    return "Any";
  } else if (valueType.tag) {
    return displayDefinedType(Belt_MapString.getExn(definitions, valueType[0]), language);
  } else {
    return displayPrimitiveValueType(valueType[0]);
  }
}

function makeNibDocs(nibs) {
  return Belt_MapString.fromArray(Belt_Array.map(nibs, (function (param) {
                    return /* tuple */[
                            param[0],
                            makeTranslatable(param[1], "en")
                          ];
                  })));
}

function makeDefinition($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, implementation, _unit) {
  var name = $staropt$star !== undefined ? $staropt$star : "";
  var description = $staropt$star$1 !== undefined ? $staropt$star$1 : "";
  var inputs = $staropt$star$2 !== undefined ? $staropt$star$2 : /* array */[];
  var outputs = $staropt$star$3 !== undefined ? $staropt$star$3 : /* array */[];
  return /* record */Block.record([
            "implementation",
            "documentation",
            "display"
          ], [
            implementation,
            Block.record([
                "name",
                "description",
                "inputs",
                "outputs"
              ], [
                makeTranslatable(name, "en"),
                makeTranslatable(description, "en"),
                makeNibDocs(inputs),
                makeNibDocs(outputs)
              ]),
            Block.record([
                "inputOrdering",
                "outputOrdering"
              ], [
                $$Array.to_list($$Array.map((function (param) {
                            return param[0];
                          }), inputs)),
                $$Array.to_list($$Array.map((function (param) {
                            return param[0];
                          }), outputs))
              ])
          ]);
}

function makeGraph($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, _unit) {
  var name = $staropt$star !== undefined ? $staropt$star : "";
  var description = $staropt$star$1 !== undefined ? $staropt$star$1 : "";
  var inputs = $staropt$star$2 !== undefined ? $staropt$star$2 : /* array */[];
  var outputs = $staropt$star$3 !== undefined ? $staropt$star$3 : /* array */[];
  var nodes = $staropt$star$4 !== undefined ? $staropt$star$4 : /* array */[];
  var connections = $staropt$star$5 !== undefined ? $staropt$star$5 : /* array */[];
  return makeDefinition(name, description, inputs, outputs, /* GraphImplementation */Block.variant("GraphImplementation", 3, [/* record */Block.record([
                    "interface",
                    "connections",
                    "nodes"
                  ], [
                    Block.record([
                        "inputTypes",
                        "outputTypes"
                      ], [
                        Belt_MapString.fromArray(Belt_Array.map(inputs, (function (param) {
                                    return /* tuple */[
                                            param[0],
                                            /* AnyType */0
                                          ];
                                  }))),
                        Belt_MapString.fromArray(Belt_Array.map(outputs, (function (param) {
                                    return /* tuple */[
                                            param[0],
                                            /* AnyType */0
                                          ];
                                  })))
                      ]),
                    Belt_Map.fromArray(connections, ConnectionComparator),
                    Belt_MapString.fromArray(nodes)
                  ])]), /* () */0);
}

var InvalidConnection = Caml_exceptions.create("Definition-ReactTemplate.InvalidConnection");

var CycleDetected = Caml_exceptions.create("Definition-ReactTemplate.CycleDetected");

exports.encodeConnectionNode = encodeConnectionNode;
exports.connectionNodeToString = connectionNodeToString;
exports.encodeConnectionNib = encodeConnectionNib;
exports.connectionNibToString = connectionNibToString;
exports.encodeConnectionSide = encodeConnectionSide;
exports.connectionSideToString = connectionSideToString;
exports.ConnectionComparator = ConnectionComparator;
exports.nibKey = nibKey;
exports.nodeKey = nodeKey;
exports.explicitConnectionSideKey = explicitConnectionSideKey;
exports.definedNodeKindToString = definedNodeKindToString;
exports.definedNodeKindHasValueInput = definedNodeKindHasValueInput;
exports.definedNodeKindHasValueOutput = definedNodeKindHasValueOutput;
exports.encodeDefinedNode = encodeDefinedNode;
exports.encodeNodeKind = encodeNodeKind;
exports.encodeNodeScope = encodeNodeScope;
exports.ScopeComparator = ScopeComparator;
exports.encodeNode = encodeNode;
exports.isFunctionDefinitionNode = isFunctionDefinitionNode;
exports.isValueNib = isValueNib;
exports.isKeywordNib = isKeywordNib;
exports.primitiveValueTypes = primitiveValueTypes;
exports.primitiveValueTypeToString = primitiveValueTypeToString;
exports.stringToPrimitiveValueType = stringToPrimitiveValueType;
exports.ValueTypeComparator = ValueTypeComparator;
exports.changeTypedFields = changeTypedFields;
exports.changeInterface = changeInterface;
exports.editInterfaceNibs = editInterfaceNibs;
exports.removeInterfaceNib = removeInterfaceNib;
exports.encodeMap = encodeMap;
exports.encodeGraphImplementation = encodeGraphImplementation;
exports.primitiveValueToType = primitiveValueToType;
exports.primitiveValueToString = primitiveValueToString;
exports.displayPrimitiveValue = displayPrimitiveValue;
exports.primitiveValueToTypeString = primitiveValueToTypeString;
exports.displayValue = displayValue;
exports.implementationName = implementationName;
exports.getTranslated = getTranslated;
exports.setTranslated = setTranslated;
exports.makeTranslatable = makeTranslatable;
exports.emptyTranslatable = emptyTranslatable;
exports.getDisplayName = getDisplayName;
exports.displayKeywordNibs = displayKeywordNibs;
exports.displayKeywordInputs = displayKeywordInputs;
exports.displayKeywordOutputs = displayKeywordOutputs;
exports.makeDisplayNibs = makeDisplayNibs;
exports.displayDefinedNode = displayDefinedNode;
exports.displayNode = displayNode;
exports.displayNibsToExplicitConnectionSides = displayNibsToExplicitConnectionSides;
exports.collectGraphNodeNibs = collectGraphNodeNibs;
exports.collectAllGraphNibs = collectAllGraphNibs;
exports.functionDefinitionNibIndex = functionDefinitionNibIndex;
exports.getNodeNibIndex = getNodeNibIndex;
exports.getOutputIndex = getOutputIndex;
exports.countNodeNibs = countNodeNibs;
exports.displayDefinedType = displayDefinedType;
exports.displayPrimitiveValueType = displayPrimitiveValueType;
exports.displayValueType = displayValueType;
exports.makeNibDocs = makeNibDocs;
exports.makeDefinition = makeDefinition;
exports.makeGraph = makeGraph;
exports.InvalidConnection = InvalidConnection;
exports.CycleDetected = CycleDetected;
/*  Not a pure module */
