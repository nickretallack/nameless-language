// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function listHas(haystack, needle) {
  return Belt_List.has(haystack, needle, Caml_obj.caml_equal);
}

function id(x) {
  return x;
}

function visitConnection(graph, dependencies, connectionSide, nodes) {
  var match = Belt_Map.get(graph[/* connections */1], connectionSide);
  if (match !== undefined) {
    var node = match[/* node */0];
    if (node) {
      var nodeID = node[0];
      if (listHas(nodes, nodeID)) {
        return nodes;
      } else {
        var nodeAcc = /* :: */[
          nodeID,
          nodes
        ];
        var match$1 = Belt_MapString.getExn(graph[/* nodes */2], nodeID)[/* kind */1];
        if (typeof match$1 === "number") {
          return nodeAcc;
        } else if (match$1.tag) {
          var match$2 = match$1[0];
          var definitionID = match$2[/* definitionID */1];
          var exit = 0;
          switch (match$2[/* kind */0]) {
            case 1 : 
                return nodes;
            case 2 : 
                return visitNibConnections(graph, dependencies, nodeID, definitionID, true, visitValueConnection(graph, dependencies, nodeID, nodes));
            case 3 : 
                return visitNibConnections(graph, dependencies, nodeID, definitionID, false, nodes);
            case 0 : 
            case 4 : 
                exit = 1;
                break;
            case 5 : 
                return visitValueConnection(graph, dependencies, nodeID, nodes);
            
          }
          if (exit === 1) {
            return visitNibConnections(graph, dependencies, nodeID, definitionID, true, nodes);
          }
          
        } else {
          return Belt_List.reduce(Belt_List.makeBy(match$1[0], id), nodeAcc, (function (nodes, index) {
                        return visitConnection(graph, dependencies, /* record */[
                                    /* node : NodeConnection */[nodeID],
                                    /* nib : PositionalConnection */Block.__(1, [index])
                                  ], nodes);
                      }));
        }
      }
    } else {
      return nodes;
    }
  } else {
    return nodes;
  }
}

function visitValueConnection(graph, dependencies, nodeID, nodes) {
  return visitConnection(graph, dependencies, /* record */[
              /* node : NodeConnection */[nodeID],
              /* nib : ValueConnection */0
            ], nodes);
}

function visitNibConnections(graph, dependencies, nodeID, definitionID, isInputs, nodes) {
  var dependency = Belt_MapString.getExn(dependencies, definitionID);
  return Belt_List.reduce(isInputs ? dependency[/* inputOrdering */1] : dependency[/* outputOrdering */2], nodes, (function (acc, nibID) {
                return visitConnection(graph, dependencies, /* record */[
                            /* node : NodeConnection */[nodeID],
                            /* nib : NibConnection */Block.__(0, [nibID])
                          ], acc);
              }));
}

function getNodeInputOrdering(graph, dependencies, outputOrdering) {
  return Belt_List.reverse(Belt_List.reduce(outputOrdering, /* [] */0, (function (acc, nibID) {
                    return visitConnection(graph, dependencies, /* record */[
                                /* node : GraphConnection */0,
                                /* nib : NibConnection */Block.__(0, [nibID])
                              ], acc);
                  })));
}

exports.getNodeInputOrdering = getNodeInputOrdering;
/* No side effect */
