// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Debug = require("bs-platform/lib/js/belt_Debug.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Nib$ReactTemplate = require("./Nib.bs.js");
var Node$ReactTemplate = require("./Node.bs.js");
var Helpers$ReactTemplate = require("../Helpers.bs.js");
var NodeMenu$ReactTemplate = require("./NodeMenu.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Interface$ReactTemplate = require("./Interface.bs.js");
var Connection$ReactTemplate = require("./Connection.bs.js");
var Definition$ReactTemplate = require("../Definition.bs.js");
var LayoutGraph$ReactTemplate = require("../display/LayoutGraph.bs.js");
var DetectCycles$ReactTemplate = require("../edit/DetectCycles.bs.js");
var GraphActions$ReactTemplate = require("../edit/GraphActions.bs.js");
var DefinitionBox$ReactTemplate = require("./DefinitionBox.bs.js");
var ColumnizeNodes$ReactTemplate = require("../display/ColumnizeNodes.bs.js");
var DefinitionHeader$ReactTemplate = require("./DefinitionHeader.bs.js");
var ConnectionBypasses$ReactTemplate = require("../display/ConnectionBypasses.bs.js");

Belt_Debug.setupChromeDebugger(/* () */0);

var connectionColors = /* array */[
  "#f58231",
  "#ffe119",
  "#bfef45",
  "#3cb44b",
  "#42d4f4",
  "#4363d8",
  "#911eb4",
  "#f032e6",
  "#469990"
];

var cmp = Caml_obj.caml_compare;

var PointerComparator = Belt_Id.MakeComparable(/* module */Block.localModule(["cmp"], [cmp]));

var $$document = document;

function preventDefault($$event) {
  $$event.preventDefault();
  return /* () */0;
}

var component = ReasonReact.reducerComponent("Graph");

function make(definitionID, definitions, implementation, definition, display, documentation, emit, error, stackFrame, _children) {
  return /* record */Block.record([
            "debugName",
            "reactClassInternal",
            "handedOffState",
            "willReceiveProps",
            "didMount",
            "didUpdate",
            "willUnmount",
            "willUpdate",
            "shouldUpdate",
            "render",
            "initialState",
            "retainedProps",
            "reducer",
            "jsElementWrapped"
          ], [
            component[/* debugName */0],
            component[/* reactClassInternal */1],
            component[/* handedOffState */2],
            component[/* willReceiveProps */3],
            (function (param) {
                $$document.addEventListener("touchmove", preventDefault, {
                      passive: false,
                      capture: true,
                      once: false
                    });
                return /* () */0;
              }),
            component[/* didUpdate */5],
            (function (param) {
                $$document.removeEventListener("touchmove", preventDefault);
                return /* () */0;
              }),
            component[/* willUpdate */7],
            component[/* shouldUpdate */8],
            (function (self) {
                var sourceToIndex = Belt_Map.reduce(implementation[/* connections */1], Belt_Map.fromArray(/* array */[], Definition$ReactTemplate.ConnectionComparator), (function (acc, _sink, source) {
                        if (Belt_Map.has(acc, source)) {
                          return acc;
                        } else {
                          return Belt_Map.set(acc, source, Belt_Map.size(acc));
                        }
                      }));
                var columnizedNodes = ColumnizeNodes$ReactTemplate.sortedColumnizedNodes(implementation[/* nodes */2], implementation[/* connections */1], definitions, display);
                var scopedNodeIDs = Belt_MapString.reduce(implementation[/* nodes */2], Belt_Map.make(Definition$ReactTemplate.ScopeComparator), (function (scopes, id, node) {
                        return Belt_Map.update(scopes, node[/* scope */0], (function (nodeIDs) {
                                      return Caml_option.some(Belt_SetString.add(nodeIDs !== undefined ? Caml_option.valFromOption(nodeIDs) : Belt_SetString.empty, id));
                                    }));
                      }));
                var match = LayoutGraph$ReactTemplate.layoutGraph(scopedNodeIDs, columnizedNodes, definitions, implementation[/* connections */1]);
                var graphSize = match[1];
                var nodeLayouts = match[0];
                var connectionBypasses = ConnectionBypasses$ReactTemplate.calculate(nodeLayouts, implementation[/* connections */1], implementation[/* nodes */2], definition, definitions, graphSize[/* columns */0]);
                var graphSize_000 = /* columns */graphSize[/* columns */0];
                var graphSize_001 = /* rows */Caml_primitive.caml_int_max(graphSize[/* rows */1], Caml_primitive.caml_int_max(Belt_List.length(definition[/* display */2][/* inputOrdering */0]), Belt_List.length(definition[/* display */2][/* outputOrdering */1])));
                var graphSize$1 = /* record */Block.record([
                    "columns",
                    "rows"
                  ], [
                    graphSize_000,
                    graphSize_001
                  ]);
                var columnWidth = 120.0 + 60.0;
                var getNodePosition = function (nodeID) {
                  var position = Belt_MapString.getExn(nodeLayouts, nodeID)[/* position */0];
                  return /* record */Block.record([
                            "x",
                            "y"
                          ], [
                            (position[/* columns */0] + 1 | 0) * columnWidth,
                            position[/* rows */1] * 20.0
                          ]);
                };
                var sizeToPixels = function (size) {
                  return /* record */Block.record([
                            "x",
                            "y"
                          ], [
                            size[/* columns */0] * columnWidth - 60.0,
                            size[/* rows */1] * 20.0
                          ]);
                };
                var graphSizePixels = sizeToPixels(graphSize$1);
                var getNodeSize = function (nodeID) {
                  return sizeToPixels(Belt_MapString.getExn(nodeLayouts, nodeID)[/* size */1]);
                };
                var isNibInternal = function (node, nib) {
                  var match = node[/* kind */1];
                  if (typeof match === "number" || !(match.tag && !(match[0][/* kind */0] !== 3 || typeof nib === "number" || nib.tag))) {
                    return false;
                  } else {
                    return true;
                  }
                };
                var nibPositionFormula = function (isInternal, isSink, nodePosition, nodeSize, nibIndex) {
                  var rightSide = isInternal ? !isSink : isSink;
                  return /* record */Block.record([
                            "x",
                            "y"
                          ], [
                            nodePosition[/* x */0] + (
                              isInternal ? (
                                  rightSide ? nodeSize[/* x */0] - 120.0 : 120.0
                                ) : (
                                  rightSide ? nodeSize[/* x */0] : 0.0
                                )
                            ),
                            nibIndex * 20.0 + 20.0 / 2.0 + nodePosition[/* y */1]
                          ]);
                };
                var getNibPosition = function (connectionSide, isSink) {
                  var match = connectionSide[/* node */0];
                  if (match) {
                    var nodeID = match[0];
                    var nodePosition = getNodePosition(nodeID);
                    var nodeSize = getNodeSize(nodeID);
                    var node = Belt_MapString.getExn(implementation[/* nodes */2], nodeID);
                    var isInternal = isNibInternal(node, connectionSide[/* nib */1]);
                    var nibIndex = Definition$ReactTemplate.getNodeNibIndex(node, definitions, connectionSide[/* nib */1], isSink);
                    return nibPositionFormula(isInternal, isSink, nodePosition, nodeSize, nibIndex);
                  } else {
                    var nibIndex$1 = Helpers$ReactTemplate.findByIndexExn(isSink ? definition[/* display */2][/* outputOrdering */1] : definition[/* display */2][/* inputOrdering */0], (function (nibID) {
                            return Caml_obj.caml_equal(/* NibConnection */Block.variant("NibConnection", 0, [nibID]), connectionSide[/* nib */1]);
                          }));
                    return nibPositionFormula(true, isSink, /* record */Block.record([
                                  "x",
                                  "y"
                                ], [
                                  0.0,
                                  20.0
                                ]), graphSizePixels, nibIndex$1);
                  }
                };
                var allNibs = Definition$ReactTemplate.collectAllGraphNibs(definition, definitions);
                var renderedConnections = Belt_Array.map(Belt_Map.toArray(implementation[/* connections */1]), (function (param) {
                        var source = param[1];
                        var sink = param[0];
                        var sourceIndex = Belt_Map.getExn(sourceToIndex, source);
                        var debugState;
                        if (stackFrame !== undefined) {
                          var stackFrame$1 = stackFrame;
                          var stackConnectionSide = stackFrame$1[/* explicitConnectionSide */1];
                          if (!stackConnectionSide[/* isSource */1] && Caml_obj.caml_equal(stackConnectionSide[/* connectionSide */0], sink)) {
                            var match = stackFrame$1[/* action */2];
                            debugState = match ? /* ReturningConnection */1 : /* EvaluatingConnection */0;
                          } else {
                            debugState = /* NoDebugConnection */2;
                          }
                        } else {
                          debugState = /* NoDebugConnection */2;
                        }
                        return ReasonReact.element(Definition$ReactTemplate.connectionSideToString(sink), undefined, Connection$ReactTemplate.make(getNibPosition(source, false), getNibPosition(sink, true), Caml_obj.caml_equal(self[/* state */1][/* selection */2], /* SelectedConnection */Block.variant("SelectedConnection", 0, [sink])), Belt_Array.getExn(connectionColors, Caml_int32.mod_(sourceIndex, connectionColors.length)), Belt_List.map(Belt_Map.getExn(connectionBypasses, sink), (function (column) {
                                              return (column + 0.5) * 20.0;
                                            })), 120.0, 60.0, (function (_event) {
                                          return Curry._1(self[/* send */3], /* SelectConnection */Block.variant("SelectConnection", 1, [sink]));
                                        }), sourceIndex, debugState, /* array */[]));
                      }));
                var renderedNibs = Belt_Array.map(Belt_List.toArray(allNibs), (function (param) {
                        var explicitConnectionSide = param[/* explicitConnectionSide */1];
                        var isSource = explicitConnectionSide[/* isSource */1];
                        var connectionSide = explicitConnectionSide[/* connectionSide */0];
                        var value = isSource && stackFrame !== undefined ? Belt_Map.get(stackFrame[/* scope */0][/* sourceValues */1], connectionSide) : undefined;
                        var match = self[/* state */1][/* selection */2];
                        var tmp;
                        tmp = typeof match === "number" || match.tag !== 1 ? false : Caml_obj.caml_equal(match[0], explicitConnectionSide);
                        return ReasonReact.element(Definition$ReactTemplate.explicitConnectionSideKey(explicitConnectionSide), undefined, Nib$ReactTemplate.make(isSource, connectionSide, getNibPosition(connectionSide, !isSource), param[/* name */0], self[/* send */3], tmp, value, /* array */[]));
                      }));
                var renderedSides = ReasonReact.element(undefined, undefined, DefinitionBox$ReactTemplate.make(Definition$ReactTemplate.getDisplayName(definition, "en"), /* record */Block.record([
                            "x",
                            "y"
                          ], [
                            0.0,
                            0.0
                          ]), graphSizePixels, 120.0, 20.0, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* array */[]));
                var renderedNodes = Belt_List.toArray(Belt_List.map(Helpers$ReactTemplate.sortBy(Belt_MapString.toList(implementation[/* nodes */2]), (function (param) {
                                return Belt_MapString.getExn(nodeLayouts, param[0])[/* depth */2];
                              })), (function (param) {
                            var nodeID = param[0];
                            var match = self[/* state */1][/* selection */2];
                            var tmp;
                            tmp = typeof match === "number" || match.tag !== 2 ? false : Belt_SetString.has(match[0], nodeID);
                            return ReasonReact.element(nodeID, undefined, Node$ReactTemplate.make(param[1], definitions, getNodePosition(nodeID), getNodeSize(nodeID), 120.0, 20.0, tmp, (function ($$event) {
                                              return Curry._1(self[/* send */3], /* SelectNode */Block.variant("SelectNode", 2, [/* record */Block.record([
                                                                "nodeID",
                                                                "additive"
                                                              ], [
                                                                nodeID,
                                                                $$event.shiftKey
                                                              ])]));
                                            }), (function (param) {
                                              return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                                "pointerID",
                                                                "action"
                                                              ], [
                                                                0,
                                                                Block.variant("StartDragging", 1, [nodeID])
                                                              ])]));
                                            }), undefined, (function ($$event) {
                                              var match = Belt_Map.get(self[/* state */1][/* pointers */0], /* Mouse */0);
                                              if (match !== undefined && match.tag) {
                                                $$event.stopPropagation();
                                                return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                                  "pointerID",
                                                                  "action"
                                                                ], [
                                                                  0,
                                                                  Block.variant("FinishDragging", 4, [/* NodeScope */Block.simpleVariant("NodeScope", [nodeID])])
                                                                ])]));
                                              } else {
                                                return /* () */0;
                                              }
                                            }), undefined, /* array */[]));
                          })));
                var renderedDrawingConnections = Helpers$ReactTemplate.renderMap((function (param) {
                        var pointerState = param[1];
                        if (pointerState.tag) {
                          return null;
                        } else {
                          var match = pointerState[0];
                          var point = match[/* point */1];
                          var match$1 = match[/* explicitConnectionSide */0];
                          var startIsSource = match$1[/* isSource */1];
                          var connectionSide = match$1[/* connectionSide */0];
                          var adjustedPoint_000 = /* x */point[/* x */0];
                          var adjustedPoint_001 = /* y */point[/* y */1] - 18.0;
                          var adjustedPoint = /* record */Block.record([
                              "x",
                              "y"
                            ], [
                              adjustedPoint_000,
                              adjustedPoint_001
                            ]);
                          return ReasonReact.element(GraphActions$ReactTemplate.pointerIDToString(param[0]), undefined, Connection$ReactTemplate.make(startIsSource ? getNibPosition(connectionSide, false) : adjustedPoint, startIsSource ? adjustedPoint : getNibPosition(connectionSide, true), undefined, "black", undefined, 120.0, 60.0, undefined, 0, undefined, /* array */[]));
                        }
                      }), self[/* state */1][/* pointers */0]);
                var match$1 = self[/* state */1][/* error */1];
                var match$2 = self[/* state */1][/* selection */2];
                var tmp;
                if (typeof match$2 === "number") {
                  tmp = null;
                } else {
                  switch (match$2.tag | 0) {
                    case 0 : 
                        var connectionSide = match$2[0];
                        tmp = React.createElement(React.Fragment, undefined, React.createElement("button", {
                                  onClick: (function (_event) {
                                      return Curry._1(emit, /* EvaluateNib */Block.variant("EvaluateNib", 9, [/* record */Block.record([
                                                        "connectionSide",
                                                        "isSource"
                                                      ], [
                                                        connectionSide,
                                                        false
                                                      ])]));
                                    })
                                }, "Debug"), React.createElement("button", {
                                  onClick: (function (_event) {
                                      return Curry._1(emit, /* RemoveConnection */Block.variant("RemoveConnection", 6, [connectionSide]));
                                    })
                                }, "Remove connection"));
                        break;
                    case 1 : 
                        var explicitConnectionSide = match$2[0];
                        tmp = React.createElement(React.Fragment, undefined, React.createElement("button", {
                                  onClick: (function (_event) {
                                      return Curry._1(emit, /* EvaluateNib */Block.variant("EvaluateNib", 9, [explicitConnectionSide]));
                                    })
                                }, "Debug"), ReasonReact.element(undefined, undefined, NodeMenu$ReactTemplate.make(definitions, implementation[/* nodes */2], explicitConnectionSide, emit, /* array */[])));
                        break;
                    case 2 : 
                        tmp = React.createElement("button", {
                              onClick: (function (_event) {
                                  return Curry._1(self[/* send */3], /* RemoveSelectedNodes */0);
                                })
                            }, "Remove Node(s)");
                        break;
                    
                  }
                }
                return React.createElement("div", undefined, React.createElement("svg", {
                                height: Helpers$ReactTemplate.pixels(graphSizePixels[/* y */1]),
                                width: Helpers$ReactTemplate.pixels(graphSizePixels[/* x */0]),
                                onMouseMove: (function ($$event) {
                                    $$event.preventDefault();
                                    return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                      "pointerID",
                                                      "action"
                                                    ], [
                                                      0,
                                                      Block.variant("MovePointer", 2, [Helpers$ReactTemplate.pointFromMouse($$event)])
                                                    ])]));
                                  }),
                                onMouseUp: (function (param) {
                                    return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                      "pointerID",
                                                      "action"
                                                    ], [
                                                      0,
                                                      0
                                                    ])]));
                                  }),
                                onTouchEnd: (function ($$event) {
                                    return Helpers$ReactTemplate.iterateTouches($$event, (function (touch) {
                                                  return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                                    "pointerID",
                                                                    "action"
                                                                  ], [
                                                                    Block.simpleVariant("Touch", [touch.identifier]),
                                                                    0
                                                                  ])]));
                                                }));
                                  }),
                                onTouchMove: (function ($$event) {
                                    return Helpers$ReactTemplate.iterateTouches($$event, (function (touch) {
                                                  return Curry._1(self[/* send */3], /* PointerAction */Block.variant("PointerAction", 0, [/* record */Block.record([
                                                                    "pointerID",
                                                                    "action"
                                                                  ], [
                                                                    Block.simpleVariant("Touch", [touch.identifier]),
                                                                    Block.variant("MovePointer", 2, [/* record */Block.record([
                                                                            "x",
                                                                            "y"
                                                                          ], [
                                                                            touch.clientX - $$event.currentTarget.offsetLeft,
                                                                            touch.clientY - $$event.currentTarget.offsetTop
                                                                          ])])
                                                                  ])]));
                                                }));
                                  })
                              }, renderedSides, renderedNodes, renderedConnections, renderedDrawingConnections, renderedNibs), ReasonReact.element(undefined, undefined, DefinitionHeader$ReactTemplate.make(definitionID, definitions, documentation, "(nameless function)", emit, error, /* array */[])), match$1 !== undefined ? React.createElement("div", {
                                  className: "error-message"
                                }, match$1) : null, tmp, React.createElement("h2", undefined, "Interface"), ReasonReact.element(undefined, undefined, Interface$ReactTemplate.make(definitions, implementation[/* interface */0], documentation, display, emit, /* array */[])));
              }),
            (function (param) {
                return /* record */Block.record([
                          "pointers",
                          "error",
                          "selection"
                        ], [
                          Belt_Map.make(PointerComparator),
                          undefined,
                          0
                        ]);
              }),
            component[/* retainedProps */11],
            (function (action, state) {
                if (typeof action === "number") {
                  var match = state[/* selection */2];
                  if (typeof match === "number" || match.tag !== 2) {
                    return /* NoUpdate */0;
                  } else {
                    var nodeIDs = match[0];
                    return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 2, [
                              /* record */Block.record([
                                  "pointers",
                                  "error",
                                  "selection"
                                ], [
                                  state[/* pointers */0],
                                  state[/* error */1],
                                  0
                                ]),
                              (function (param) {
                                  return Curry._1(emit, /* RemoveNodes */Block.variant("RemoveNodes", 7, [nodeIDs]));
                                })
                            ]);
                  }
                } else {
                  switch (action.tag | 0) {
                    case 0 : 
                        var match$1 = action[0];
                        var action$1 = match$1[/* action */1];
                        var pointerID = match$1[/* pointerID */0];
                        if (typeof action$1 === "number") {
                          if (action$1 === 0) {
                            var match$2 = Belt_Map.get(state[/* pointers */0], pointerID);
                            if (match$2 !== undefined) {
                              var match$3 = match$2;
                              if (match$3.tag) {
                                var nodeID = match$3[0];
                                return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 2, [
                                          /* record */Block.record([
                                              "pointers",
                                              "error",
                                              "selection"
                                            ], [
                                              Belt_Map.remove(state[/* pointers */0], pointerID),
                                              state[/* error */1],
                                              state[/* selection */2]
                                            ]),
                                          (function (param) {
                                              return Curry._1(emit, /* ChangeNodeScope */Block.variant("ChangeNodeScope", 8, [/* record */Block.record([
                                                                "nodeID",
                                                                "nodeScope"
                                                              ], [
                                                                nodeID,
                                                                0
                                                              ])]));
                                            })
                                        ]);
                              } else {
                                return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                              "pointers",
                                              "error",
                                              "selection"
                                            ], [
                                              Belt_Map.remove(state[/* pointers */0], pointerID),
                                              state[/* error */1],
                                              state[/* selection */2]
                                            ])]);
                              }
                            } else {
                              return /* NoUpdate */0;
                            }
                          } else {
                            var match$4 = state[/* selection */2];
                            if (typeof match$4 === "number") {
                              throw Caml_builtin_exceptions.not_found;
                            } else {
                              switch (match$4.tag | 0) {
                                case 0 : 
                                    var connectionSide = match$4[0];
                                    return /* SideEffects */Block.variant("SideEffects", 1, [(function (param) {
                                                  return Curry._1(emit, /* EvaluateNib */Block.variant("EvaluateNib", 9, [/* record */Block.record([
                                                                    "connectionSide",
                                                                    "isSource"
                                                                  ], [
                                                                    connectionSide,
                                                                    false
                                                                  ])]));
                                                })]);
                                case 1 : 
                                    var explicitConnectionSide = match$4[0];
                                    return /* SideEffects */Block.variant("SideEffects", 1, [(function (param) {
                                                  return Curry._1(emit, /* EvaluateNib */Block.variant("EvaluateNib", 9, [explicitConnectionSide]));
                                                })]);
                                case 2 : 
                                    throw Caml_builtin_exceptions.not_found;
                                
                              }
                            }
                          }
                        } else {
                          switch (action$1.tag | 0) {
                            case 0 : 
                                return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                              "pointers",
                                              "error",
                                              "selection"
                                            ], [
                                              Belt_Map.set(state[/* pointers */0], pointerID, /* DrawingConnection */Block.variant("DrawingConnection", 0, [action$1[0]])),
                                              state[/* error */1],
                                              state[/* selection */2]
                                            ])]);
                            case 1 : 
                                return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                              "pointers",
                                              "error",
                                              "selection"
                                            ], [
                                              Belt_Map.set(state[/* pointers */0], pointerID, /* DraggingNode */Block.variant("DraggingNode", 1, [action$1[0]])),
                                              state[/* error */1],
                                              state[/* selection */2]
                                            ])]);
                            case 2 : 
                                var match$5 = Belt_Map.get(state[/* pointers */0], pointerID);
                                if (match$5 !== undefined) {
                                  var match$6 = match$5;
                                  if (match$6.tag) {
                                    return /* NoUpdate */0;
                                  } else {
                                    return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                                  "pointers",
                                                  "error",
                                                  "selection"
                                                ], [
                                                  Belt_Map.set(state[/* pointers */0], pointerID, /* DrawingConnection */Block.variant("DrawingConnection", 0, [/* record */Block.record([
                                                              "explicitConnectionSide",
                                                              "point"
                                                            ], [
                                                              match$6[0][/* explicitConnectionSide */0],
                                                              action$1[0]
                                                            ])])),
                                                  state[/* error */1],
                                                  state[/* selection */2]
                                                ])]);
                                  }
                                } else {
                                  return /* NoUpdate */0;
                                }
                            case 3 : 
                                var match$7 = action$1[0];
                                var endNib = match$7[/* connectionSide */0];
                                var match$8 = Belt_Map.get(state[/* pointers */0], pointerID);
                                if (match$8 !== undefined) {
                                  var match$9 = match$8;
                                  if (match$9.tag) {
                                    return /* NoUpdate */0;
                                  } else {
                                    var match$10 = match$9[0][/* explicitConnectionSide */0];
                                    var startIsSource = match$10[/* isSource */1];
                                    var startNib = match$10[/* connectionSide */0];
                                    if (startIsSource === match$7[/* isSource */1]) {
                                      if (Caml_obj.caml_equal(startNib, endNib)) {
                                        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                                      "pointers",
                                                      "error",
                                                      "selection"
                                                    ], [
                                                      state[/* pointers */0],
                                                      undefined,
                                                      Block.variant("SelectedNib", 1, [/* record */Block.record([
                                                              "connectionSide",
                                                              "isSource"
                                                            ], [
                                                              startNib,
                                                              startIsSource
                                                            ])])
                                                    ])]);
                                      } else {
                                        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                                      "pointers",
                                                      "error",
                                                      "selection"
                                                    ], [
                                                      state[/* pointers */0],
                                                      startIsSource ? "Can't connect a source to a source" : "Can't connect a sink to a sink",
                                                      state[/* selection */2]
                                                    ])]);
                                      }
                                    } else {
                                      var match$11 = startIsSource ? /* tuple */[
                                          startNib,
                                          endNib
                                        ] : /* tuple */[
                                          endNib,
                                          startNib
                                        ];
                                      var sink = match$11[1];
                                      var source = match$11[0];
                                      if (DetectCycles$ReactTemplate.checkConnectionScope(source, sink, implementation[/* nodes */2])) {
                                        if (DetectCycles$ReactTemplate.detectCycles(Belt_Map.set(implementation[/* connections */1], sink, source), implementation[/* nodes */2])) {
                                          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                                        "pointers",
                                                        "error",
                                                        "selection"
                                                      ], [
                                                        state[/* pointers */0],
                                                        "Can't create cycles",
                                                        state[/* selection */2]
                                                      ])]);
                                        } else {
                                          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 2, [
                                                    /* record */Block.record([
                                                        "pointers",
                                                        "error",
                                                        "selection"
                                                      ], [
                                                        Belt_Map.remove(state[/* pointers */0], pointerID),
                                                        undefined,
                                                        state[/* selection */2]
                                                      ]),
                                                    (function (param) {
                                                        return Curry._1(emit, /* CreateConnection */Block.variant("CreateConnection", 0, [/* record */Block.record([
                                                                          "source",
                                                                          "sink"
                                                                        ], [
                                                                          source,
                                                                          sink
                                                                        ])]));
                                                      })
                                                  ]);
                                        }
                                      } else {
                                        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                                      "pointers",
                                                      "error",
                                                      "selection"
                                                    ], [
                                                      state[/* pointers */0],
                                                      "When crossing scopes, you can only connect a source in a parent scope to a sink in a child scope.",
                                                      state[/* selection */2]
                                                    ])]);
                                      }
                                    }
                                  }
                                } else {
                                  return /* NoUpdate */0;
                                }
                            case 4 : 
                                var nodeScope = action$1[0];
                                var match$12 = Belt_Map.get(state[/* pointers */0], pointerID);
                                if (match$12 !== undefined) {
                                  var match$13 = match$12;
                                  if (match$13.tag) {
                                    var nodeID$1 = match$13[0];
                                    return /* SideEffects */Block.variant("SideEffects", 1, [(function (param) {
                                                  return Curry._1(emit, /* ChangeNodeScope */Block.variant("ChangeNodeScope", 8, [/* record */Block.record([
                                                                    "nodeID",
                                                                    "nodeScope"
                                                                  ], [
                                                                    nodeID$1,
                                                                    nodeScope
                                                                  ])]));
                                                })]);
                                  } else {
                                    return /* NoUpdate */0;
                                  }
                                } else {
                                  return /* NoUpdate */0;
                                }
                            
                          }
                        }
                    case 1 : 
                        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                      "pointers",
                                      "error",
                                      "selection"
                                    ], [
                                      state[/* pointers */0],
                                      state[/* error */1],
                                      Block.variant("SelectedConnection", 0, [action[0]])
                                    ])]);
                    case 2 : 
                        var match$14 = action[0];
                        var nodeID$2 = match$14[/* nodeID */0];
                        var match$15 = state[/* selection */2];
                        var tmp;
                        if (typeof match$15 === "number") {
                          tmp = /* SelectedNodes */Block.variant("SelectedNodes", 2, [Belt_SetString.fromArray(/* array */[nodeID$2])]);
                        } else if (match$15.tag === 2) {
                          var nodeIDs$1 = match$15[0];
                          if (match$14[/* additive */1]) {
                            if (Belt_SetString.has(nodeIDs$1, nodeID$2)) {
                              var newNodeIDs = Belt_SetString.remove(nodeIDs$1, nodeID$2);
                              tmp = Belt_SetString.isEmpty(newNodeIDs) ? /* NoSelection */0 : /* SelectedNodes */Block.variant("SelectedNodes", 2, [newNodeIDs]);
                            } else {
                              tmp = /* SelectedNodes */Block.variant("SelectedNodes", 2, [Belt_SetString.add(nodeIDs$1, nodeID$2)]);
                            }
                          } else {
                            tmp = /* SelectedNodes */Block.variant("SelectedNodes", 2, [Belt_SetString.fromArray(/* array */[nodeID$2])]);
                          }
                        } else {
                          tmp = /* SelectedNodes */Block.variant("SelectedNodes", 2, [Belt_SetString.fromArray(/* array */[nodeID$2])]);
                        }
                        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                      "pointers",
                                      "error",
                                      "selection"
                                    ], [
                                      state[/* pointers */0],
                                      state[/* error */1],
                                      tmp
                                    ])]);
                    
                  }
                }
              }),
            component[/* jsElementWrapped */13]
          ]);
}

exports.connectionColors = connectionColors;
exports.PointerComparator = PointerComparator;
exports.$$document = $$document;
exports.preventDefault = preventDefault;
exports.component = component;
exports.make = make;
/*  Not a pure module */
