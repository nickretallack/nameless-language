// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Evaluate$ReactTemplate = require("./Evaluate.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function evaluateInput(inputs, inputID) {
  var match = Belt_MapString.getExn(inputs, inputID);
  if (match !== undefined) {
    return /* EvaluationResult */Block.variant("EvaluationResult", 0, [match]);
  } else {
    return /* EvaluationRequired */Block.variant("EvaluationRequired", 1, [/* :: */Block.simpleVariant("::", [
                  inputID,
                  /* [] */0
                ])]);
  }
}

function conditionalBranch(inputs, outputID) {
  if (outputID !== "result") {
    throw Caml_builtin_exceptions.not_found;
  }
  var match = Belt_MapString.getExn(inputs, "if");
  if (match !== undefined) {
    var match$1 = match;
    if (match$1.tag) {
      switch (match$1[0][/* definitionID */0]) {
        case "no" : 
            return evaluateInput(inputs, "else");
        case "yes" : 
            return evaluateInput(inputs, "then");
        default:
          throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    return /* EvaluationRequired */Block.variant("EvaluationRequired", 1, [/* :: */Block.simpleVariant("::", [
                  "if",
                  /* [] */0
                ])]);
  }
}

function withAllValues(inputs, operation) {
  var match = Belt_MapString.reduce(inputs, /* tuple */[
        Belt_MapString.empty,
        /* [] */0
      ], (function (param, key, value) {
          var needed = param[1];
          var values = param[0];
          if (value !== undefined) {
            return /* tuple */[
                    Belt_MapString.set(values, key, value),
                    needed
                  ];
          } else {
            return /* tuple */[
                    values,
                    Belt_List.add(needed, key)
                  ];
          }
        }));
  var needed = match[1];
  if (Belt_List.length(needed) !== 0) {
    return /* EvaluationRequired */Block.variant("EvaluationRequired", 1, [/* :: */Block.simpleVariant("::", [
                  Belt_List.headExn(needed),
                  /* [] */0
                ])]);
  } else {
    return /* EvaluationResult */Block.variant("EvaluationResult", 0, [Curry._1(operation, match[0])]);
  }
}

function numericOperator(operation, inputs, outputID) {
  if (outputID !== "result") {
    throw Caml_builtin_exceptions.not_found;
  }
  return withAllValues(inputs, (function (values) {
                return /* PrimitiveValue */Block.variant("PrimitiveValue", 0, [/* NumberValue */Block.variant("NumberValue", 1, [Curry._2(operation, Evaluate$ReactTemplate.getNumber(Belt_MapString.getExn(values, "left")), Evaluate$ReactTemplate.getNumber(Belt_MapString.getExn(values, "right")))])]);
              }));
}

function numericComparison(comparison, inputs, outputID) {
  if (outputID !== "result") {
    throw Caml_builtin_exceptions.not_found;
  }
  return withAllValues(inputs, (function (values) {
                var match = Curry._2(comparison, Evaluate$ReactTemplate.getNumber(Belt_MapString.getExn(values, "left")), Evaluate$ReactTemplate.getNumber(Belt_MapString.getExn(values, "right")));
                return /* DefinedValue */Block.variant("DefinedValue", 1, [/* record */Block.record([
                              "definitionID",
                              "values"
                            ], [
                              match ? "yes" : "no",
                              0
                            ])]);
              }));
}

function evaluateExternal(name, outputID, inputs) {
  var externalFunction;
  switch (name) {
    case "*" : 
        externalFunction = (function (param, param$1) {
            return numericOperator((function (prim, prim$1) {
                          return prim * prim$1;
                        }), param, param$1);
          });
        break;
    case "+" : 
        externalFunction = (function (param, param$1) {
            return numericOperator((function (prim, prim$1) {
                          return prim + prim$1;
                        }), param, param$1);
          });
        break;
    case "-" : 
        externalFunction = (function (param, param$1) {
            return numericOperator((function (prim, prim$1) {
                          return prim - prim$1;
                        }), param, param$1);
          });
        break;
    case "/" : 
        externalFunction = (function (param, param$1) {
            return numericOperator((function (prim, prim$1) {
                          return prim / prim$1;
                        }), param, param$1);
          });
        break;
    case "<" : 
        externalFunction = (function (param, param$1) {
            return numericComparison(Caml_obj.caml_lessthan, param, param$1);
          });
        break;
    case "<=" : 
        externalFunction = (function (param, param$1) {
            return numericComparison(Caml_obj.caml_lessequal, param, param$1);
          });
        break;
    case "==" : 
        externalFunction = (function (param, param$1) {
            return numericComparison(Caml_obj.caml_equal, param, param$1);
          });
        break;
    case ">" : 
        externalFunction = (function (param, param$1) {
            return numericComparison(Caml_obj.caml_greaterthan, param, param$1);
          });
        break;
    case ">=" : 
        externalFunction = (function (param, param$1) {
            return numericComparison(Caml_obj.caml_greaterequal, param, param$1);
          });
        break;
    case "branch" : 
        externalFunction = conditionalBranch;
        break;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
  return Curry._2(externalFunction, inputs, outputID);
}

exports.evaluateInput = evaluateInput;
exports.conditionalBranch = conditionalBranch;
exports.withAllValues = withAllValues;
exports.numericOperator = numericOperator;
exports.numericComparison = numericComparison;
exports.evaluateExternal = evaluateExternal;
/* Evaluate-ReactTemplate Not a pure module */
